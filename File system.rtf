{\rtf1\ansi\ansicpg1252\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil Calibri;}}
{\*\generator Riched20 10.0.17763}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang16 Lo strumento <Esplora risorse> di Windows consente all'utente di gestire i file presenti nel computer:\par
In realt\'e0 i file sono memorizzati in modo non volatile.\line Tradizionalmente l'unit\'e0 di memoria persistente di un computer \'e8 costituita da un disco rotante di materiale magnetico dotata di una testina mobile per la lettura/scrittura dei dati, ma negli ultimi anni si sono diffuse le unit\'e0 allo stato solido, realizzate con la tecnilogia elettronica FLASH e avanti prestazioni superiori in relazioni alla velocit\'e0 dei dati.\line\line In entrambi i casi un dispositivo di memoria persistente ha una velocit\'e0 che \'e8 circa un milione di volte inferiore alla memoria principale, per cui il gestore del file-system deve adottare tecniche anche complesse per garantire prestazioni del computer all'interno del quale occupa un ruolo non secondario.\par
\line Tutti i sistemi operativi espongono all'utente la memoria persistente del computer come un sistema di file organizzano in strutture contenitore denominate directory. Ogni directory puo' contenere altre directory e/o file realizzando una struttura ad albero.\line Rappresentando l'organizzazione del file-system come un albero in cui la directory di livello piu' alto \'e8 la radice e i file sono le foglie, ogni singolo file puo' essere univocamente identificato dalla sequenza ordinaria dei nomi delle directory del percorso (pathname) che lo connette alla radice.\line Le interfacce utente dei sistemi operativi consentono la navigazione dell'albero delle directory e le piu' comuni operazioni sui file che esse contengono:\line\f1\bullet\f0 Elencazione\line\f1\lang1040\bullet\f0 Eliminazione\line\f1\bullet\f0 Ridenominazione\line\f1\bullet\f0 Copia\line\f1\bullet\f0 Spostamento\line\f1\bullet\f0 Visualizzazione delle propriet\'e0\line L'apertura di un file richiede l'esecuzione di un programma in grado di interprestare il contenuto nel particolare formato interno con cui \'e8 stato memorizzato.\par
I sistemi operativi associano ai vari formati dei file di dati corrispondenti programmi applicativi in due modi diversi:\line\f1\bullet\f0 L'estensione del nome del file costituita dagli ultimi 3 o 4 cartteri\line\f1\bullet\f0 Un codice identificativo (noto come magic number) memorizzato nei primi byte del file\line\line Un programma applicativo necessita di eseguire alcune tipiche operazioni sui file di dati su cui opera:\line\f1\bullet\f0 Apertura\line\f1\bullet\f0 Lettura di dati\line\f1\bullet\f0 Scrittura dei dati\line\f1\bullet\f0 Posizionamento\line\f1\bullet\f0 Chiusura\line\line Una volta aperto u n file identificato univocamente dal nome o dal pathname, un programma opera leggendo dal file e/o scrivendo nel file blocchi di dati in una qualsiasi posizione.\line Tutti i sistemi operativi hanno un ricco insieme di funzionalit\'e0 API per gestione dei file, ma la necessit\'e0 di renderle indipedente dalla piattaforma questo aspetto fondamentale ha portato alla loro standardizzazione all'interno delle librerie dei vari linguaggi di programmazione.\line I programmi applicativi necessitano di accedere ai dati contenuti in un file in modo non rigorosamente sequenziale, altrimenti non sarebbe possibile, per esempio, <saltare> a una particolare scena di un video, ma sarebbe necessario attendere la visualizzazione da parte del produttore multimediale. Questa necessit\'e0 ha un impatto importante sulla modalit\'e0 di memorizzazione del contenuto dei file da parte del sistema operativo.\par
\par
\par
Capitolo 2:\line Nel caso in cui l'unit\'e0 di memoria persistente \'e8 costituita da un disco magnetico, questo \'e8 mantenuto in rapida rotazione intorno al proprio asse ed \'e8 possibile posizionare una testina per la lettura/scrittura dei dati.\line Il posizionamento della testina individua sopra alla superficie una successione di tracce circolari concentriche, mentre la rotazione del disco sotto di essa individua una sequenza di settori circolari per ciscuna di esse.\line\line "La lettura/scrittura dei dati dal e sul disco avviene per singoli settori di traccia inviduati dalle rispettive coordinate nella geomtria del disco: traccia e settore."\line\line Per motivi tecnologici un settore di traccia ha la tipica capacit\'e0 di 512 byte, ma i gestori del file-system dei sistemi operativi considerano piu' settori consecutivi della stessa traccia come un unico blocco di dati (cluster) da leggere e scrivere sempre nella sua interezza.\line Questa modalit\'e0 di lettura/scrittura dei dati \'e8 finalizzata all'ottimizzazione delle prestazioni di un dispositivo per sua caratteristica estremamente lento: una volta posizionato la testina sulla traccia specifica, si deve infatti attendere che il settore richiesto si trovi sotto di essa; la lettura/scrittura di piu' settori consecutivi non richiede nuovi spostamenti della testina, o attesse della rotazione del disco.\line\par
\lang16 Nel caso invece in cui l'unit\'e0 di memoria persistente \'e8 costituita da un dispositivo SSD internamente organizzato in pagine di dimensione fissa, tipicamente di 4 Kilobyte.\line "La pagina di un dispositivo SSD \'e8 identificata da uno o piu' valori numerici e rappresenta l'insieme minimo di dati che possono essere letti o scritti in un'unica operazione da parte del computer."\line\line La scrittura deve avvenire in una pagina cancellata e la cancellazione deve essere effettuata per un intero blocco di pagina, formato, per esempio da 128 pagine.\line Inoltre il numero di volte che una pagina puo' essere cancellata \'e8 limitato e, per garantire una lunga vita operativa di un SSD, la cancellazione delle pagine deve essere effettuata nel tempo in modo uniforme su tutti i blocchi. Dato che la cancellazione di un blocco \'e8 un'operazione lenta, le versioni piu' recenti dei sistemi operativi prevedono una specifica azione (trim) con cui il gestore del file-system indica al driver SSD quali blocchi di pagina puo' cancellare anticipandone in questo modo la disponibilit\'e0 per il futuro riuso.\line "Per quanto tecnologicamente molto diversa da un HDD, SSD espone al sistema operastivo del computer un'interfaccia operativa simile, costituta da un numero elevato di elementi (settori o pagine) leggibili e scrivibili, ciscuno dei quali indirizzabile mediante uno o piu' indici numerici.\par
Il gestore del file-system di un sistema operativo deve normalmente organizzare centinaia di migliaia di file con dimensioni estramente vatiabili. Oltretutto, nonostante la tipica caratteristica di memorizzazione persistente che il file-system realizza, la variazione dei dati \'e8 estremamente alta: i file sono infatti continuamente creati ed eliminati e il loro contenuto viene frequentemente aggiornato.\line L'idea ingenua di memorizzare sequenzialmente in settori consecutivi di tracce contigue del disco, o di pagina consecutive e contigue di un'unit\'e0 SSD, ogni singolo file non \'e8 mai stata presa in considerazione dai progettisti fi file-system perch\'e8 presenta due gravi errori:\line\f1\bullet\f0 una volta che lo spazio destinato alla memorizzazione di un file \'e8 incastrato tra gli spazi allocati ad altri file, diventa impossibile aumentare le dimensioni, se non copiando preventivamente in una zona libera sufficintemente grande\line\f1\bullet\f0 La continua cancellazione dei file causa il problema della frammentazione dello spazio libero: tutto l ospazio disponibile per la memorizzazione di nuovi file sarebbe distribuito in brevissime sequenza di blocchi o di pagine contigui in cui non risulterebbe possibile memorizzare file se non dimensioni piccolissime.\line\line La memorizzazione in blocchi non contigui dei file risolve il problema della frammentazione dello spazio libero, ma l'elevato numero di blocchi di un'unit\'e0 di memoria persistente attuale rende non praticabile la memorizzazione di tabelle di allocazione dei blocchi logici dei singoli file nei corrispondenti blocchi fisici del disco, pagine SSD.\line\tab Una soluzione possibile ed effettivamente implementata in passato da alcuni sistemi operativi \'e8 quella di collegare i blocchi che compongono file in una catena dopo ogni blocco inseriti i numeri di traccia e di settore o il numero di pagina del blocco successiva o l'indicazione che si tratta dell'ultimo blocco del file:\line In questo modo, nella tabella che i lgestore del file-system deve mantenere per localizzazione i singoli file contenuti in una directory, \'e8 sufficiente riportare i numeri relativi al primo blocco del file. Questa soluzione risolve il problema della variazione della dimensione di un file perch\'e8 i blocchi possono essere collocati in modo contiguo, ma non viene mai adottata.\line\line La soluzione dei blocchi concatenati ha infatti un grave difetto: Dovendo accedere agli ultimi dati di un file \'e8 necessario scorrere sequenzialmente tutti i blocchi precedenti: nel caso di file di dimensioni notevoli questo metodo \'e8 altamente inefficiente.\line La tecnica adottata dalla maggior parte dei file-system \'e8 denominata indicizzazione ad albero ed \'e8 un intelligente compromesso tra l'impraticabilit\'e0 delle tabelle di indicizzazione di tutti i blocchi e l'inefficienza della concatenazione dei blocchi stessi.\line\line Nella tabella che rappresenta la directory, per ogni file sono mantenuti i numeri relativi a un numero limitato di blocchi; se il file \'e8 costituito da pochi blocchi di dati, questi sono gli indici dei blocchi corrispondenti. Altrimenti, se il file \'e8 costituito da piu' blocchi, gli ultimi blocchi conterrano le coordinate di traccia/settore o il numero di pagina che costituiscono un indice per ulteriori blocchi di dati.\line La struttura ad albero utilzizata per la gestione dei blocchi che costituiscono i file nell'unit\'e0 di memoria di massa non ha nulla in comune con l'organizzazione dei directory e dei file: Si tratta di due livelli di organizzazione del tutto diversi.\line\line All'umentare del numero di blocchi di dati che costituiscono il file, anche i blocchi di secondo livello individuano, anzich\'e8 direttamente blocchi di dati, blocchi contenenti riferimenti ad altri blocchi, realizzando una struttura ad albero.\line Nelle figure precedenti il massimo numero di coordinate contenute in ogni blocco indice \'e8 stato fissato a 4, ma nella realt\'e0 \'e8 notevolmente superiore.\line Esempio prevedendo 8 indici nella tabella della directory e fino a 256 indici per ogni blocco e impiegando al massimo di 3 livelli di indicizzazione, si riescono a gestire file fino alla dimensione di 8 x 256(3) = 134217728 blocchi\line che con blocchi di 4 kb corrispondono a 512 Gigabyte.\line\line L'adizione dello schema di memorizzazione dei file con indicizzazione ad albero dei blocchi ha come conseguenza l'accesso relativamente rapido ai dati contenuti in file di piccola dimensione e una minore velocit\'e0 di reperimento dei dati contenuti in file di grande dimensione, per i quali diviene necessario leggere diversi blocchi indice in cascata prima di ottenere i numeri di traccia/settore o il numero di pagina del cluster richiesto.\line La limitazione del numero di livelli di indicizzazione consent comunque di mantenere un'elevata efficienza rispetto alla tecnica della concatenazione dei blocchi.\par
I sistemi operativi moderni limitano l'uso della concatenazione dei blocchi unicamente alla gestione dello spazio libero: i blocchi non occupati sono concatenati in una lista da dove vengono rimossi quando allocati per l'stensione di file gi\'e0 esistenti, o per la creazione di nuovi file.\line Un modo alternativo di gestire lo spazio libero \'e8 quello di mantenere una bitmap che associa in forma binaria a ogni cluster del disco o a una pagina di un'unit\'e0 SSD il suo stato: libero o occupato.\line\tab Questa sequenza di bit viene memorizzata in una posizione fissa.\par
\line ORGANIZZAZIONE DELLE PRESTAZIONI DEL FILE-SYSTEM\line La memoria di massa \'e8 mediamente un milione di volte piu' lenta della memoria principale  del computer, di conseguenza l'ottimizzazione delle prestazioni del file-system \'e8 sempre stato un tema fondamentale per i progettisti dei sistemi operativi.\line Nel caso del disco \'e8 importante ottimizzare il movimento della testina, evitando continui spostamenti dalle posizioni interne a quelle esterne sulla superificie.\line\line Una politica comunemente adottata per ottimizzare lo spostamento della testina del disco \'e8 l'algoritmo dell'ascensore, cos\'ec chiamato per analogia con la strategia di ottimizazione dei percorsi di salita e discesa dell'ascensore di un grattacielo:\line L'algoritmo consiste nel servire le richieste ricevute non nell'ordine con cui sono state generate, ma alternando il movimento della testina nei due sensi e servendo le richieste in ordine crescende o decrescente di traccia.\line Un parametro da ottimizzare sempre legato al movimento del disco \'e8 la dimensione del cluster di settori di traccia cui il gestore del file-system accede in un'unica operazione.\line Figura 12 sintetizza due aspetti contrastanti:\line\f1\bullet\f0 Il cluster formato da molti settori consecutivi diminuisce il numero medio degli accessi al disco per operazioni di l/s, aumentando in media le prestazioni.\line\f1\bullet\f0 Il cluster di dimensione elevata non ottimizza l'uso dello spazio del disco, in quanto l'ultimo cluster allocato a ogni singolo file viene utilizzato solo in parte.\line\line Il fatto che il tempo di accesso ai dati memorizzati su un'unit\'e0 di memoria persistente sia circa un milione superiore al tempo di accesso ai dati presenti in memoria principali ha suggerito ai progettisti di sistemi operativi di ottimizzare il tempo medio di accesso implementando nel gestore del file-system una cache in memoria Ram dei dati contenuti nei file.\line Basandosi sul fatto che prevalentemente i programmi accedono ai file in modalit\'e0 sequenziale o comunque locale rispetto all'ultima operazione di l/s, il gestore del file-system memorizza in un buffr allocato nella memoria principale i dati contenuti nei blocchi immediatamente precedenti o successivi all'ultimo blocco acceduto, nel tentativo di anticipare le richieste future del programma che sta utilizzando il file: nei casi in cui cio' avviene si ha un considerevole risparmio di tempo e staticamente le prestazioni del file-system risultano essere molto migliori.\line Un malfunzionamento, come una banale interruzione di alimentazione elettrica nel corso di un'operazione di scrittura su un disco, puo' comportare la perdit\'e0 di integrit\'e0 del file-system, con conseguente perdita dei dati memorizzatinei file su disco. Allo scopo di elevare l'affidabilit\'e0, i moderni file-system implementano la tecnica del journaling: prima di effettuare operazioni sul disco il sistema operativo le annota in uno speciale file di log; nello stesso file riporta le operazioni effettivamente concluse. In caso di crash la lettura del file di log consente di sapere quali operazioni sono rimaste incomplete e di ripristinare uno stato consistente. PRaticamente i moderni file-system sono di questo tipo.\par
}
 