{\rtf1\ansi\ansicpg1252\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil Calibri;}}
{\*\generator Riched20 10.0.17763}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang16\par
L'architettura interna\par
8086: L'architettura interna presente alcune caratteristiche e componenti che si ritorvano potenziate nei successivi processori della stessa famiglia.\line La Cpu \'e8 divisa in due parti: la Eu (Execution Unit) preposta all'esecuzione delle istruzione e la BIU (Bus Interface Unit) Preposta alla comunzione con il bus.\line\line La caratteristica piu' rilevante del sistema \'e8 che queste due parti sono lavorare autonomamente l'una rispetto all'altra. Le due parti comunicano tramite una coda di registri (gestita con la politica FIFO).\line\line Registri CPU 8086\line E' dotata dei seguenti registri, tutti a 16 bit:\par
Registri di uso generale:\line AX > REGISTRO ACUMULATORE\line BX > Registro base (contiene la base di un indirizzo relativo)\line CX > Registro Contatore (UIsato per esempio nell'istruzione Loop)\line DX > Data register (Usato in istruzione arimetiche e di I/O)\line\line Registri indice e puntatori\line SI > Registro indice sorgente (Usato come puntatore nelle istruzioni di manipolazione di stringhe)\line DI > Registro Indice destinazione. (Usato come SI)\line BP > Base Pointer (puntatore alla base dello stack) (Usato nelle operazioni sullo stack)\line IP > Istruction Pointer (Program counter)\line\line Registro di stato\line SR Status Register > Definisce lo stato della CPU\line Il registro di stato \'e8 costitutito da 16 bit. Di cui 7 non sono utilizzati.\line I 9 utilizzati sono divisi in due gruppi: Bit di controllo (3) Bit di stato (6)\par
\line Organizzazione dell memoria:\line 8086 Dispone di un bus indirizzi a 20 linee, in grado di indirizzare 1 MB di memoria, dall'indirizzo 00000h all'indirizzo FFFFFh. Le prime 16 linee dell'indirizzo (Da 0 a 15) Servono anche a indirizzare le periferiche coivolte nelle operazioni di input/output. Le periferiche indirizzabili possono essere al massimo 2 alla 16 overo 65 536.\line Poich\'e8 la Cpu utilizza un bus di dati a 16 linee, \'e8 possibile trasferire 2 byte alla volta in un'unica operazione; in questo modo con un unico accesso alla memoria \'e8 possibile trasferire 2 byte.\par
Gestione della memoria del sistema:\line Indirizzamento\line Affrontiamo ora il problema della gestione della memoria:\line Ogni processore necessita di memoria da cui legge istruzioni/Dati: memoria RAM.\line La quantit\'e0 di memoria indirizzabile \'e8 strettamente dipendente dalla dimensione del bus indirizzi: Maggiore \'e8 la dimensione del bus,maggiore \'e8 la memoria indirizzabile.\line Questo ha a sua volta un impatto sulle prestazione del sistema in quanto memoria centrale limitata rende necessari numerosi acessi al disco, con notevole diminuzione della velocit\'e0 e della produttivit\'e0 del sistema.\line E' importante sottolineare che se anche avessimo a disposizione 4 MB di memoria, per esempio, se questa non \'e8 indirizzabile perch\'e8 le line del bus indirizzi non sono sufficienti, la parte non indirizzabile non puo' essere utilizzata.\line Con bus indirizzi a 16 linee \'e8 possibile indirizzare fino a 64 KB.\line\line Il sistema 8086 \'e8 dotata di un bus dati a 16 bit e un bus indirizzi a 20 bit.\line Quindi ha un bus indirizzi di 20 linee con cui \'e8 possibile indirizzare fino a 1 MB.\line Ogni locazione \'e8 indirizzabile con 20 bit (5 cifre esadecimali) e vengono gestiti da 00000f e FFFFFh (indirizzo fisico) che definiscono univocamente una locazione di memoria.\line L'indirizzo fisico \'e8 di 20 bit, ma i registri a 16 bit.\line\line il problema: Come puo' un registro contenere l'intero indirizzo?\line Effettivamente \'e8 impossibile, ma la memoria 8086 \'e8 divisa in segmenti, cisciuno di 64 KB\line Un segmento \'e8 una porzione di RAM che contiene un determinato tipo di informazione.\line OGni segmento ha al massimo locazioni di indirizzo 0000h-FFFFh che possono essere indirizzate con 16 bit.\par
Ecco allora la soluzione: indicare il segmento coinvolto e all'interno del segmento la locazione desiderata.\line Puo' essere fatto utilizzando un indirizzo relativo che prevede una base e uno spazzamento.\line\line L'indirizzo fisico con 20 bit \'e8 anche detto assoluto,\line Quello logico espresso una coppia di 2 numeri di 16 bit \'e8 anche detto relativo.\line\line Per questo motivo a livello software \'e8 definito un indirizzamento segmentato costituto da due numeri di 4 cifre esadecimali ciascuno:\line\f1\bullet\f0 Il primo numero costituisce la base;\line\f1\bullet\f0 Il secondo numero lo spiazzamento.\line\line Segmentazione.\line E' una tecnica di gestione della memoria. Con la gestione della memoria segmentata un programma \'e8 diviso in segmento che contengono ciascuno un tipo di informazione: o dati o istruzioni.\line Un segmento \'e8 una parte di Ram in cui viene caricata la corrispondente parte di programma.\line 8086 prevede 4 tipi di segmenti:\par
CS Code Segment > Contiene l'indirizzo di inizio del code segment\line DS Data Segment > Contiene l'indirizzo di inizio del data segment\line SS Stacik Segment > Contiene l'indirizzo di inizio dello stack segment\line ES Extra Segment > Contiene l'indirizzo di inizio dell'extra segment\par
\par
Per indirizzare una locazione all'interno di un segmento, utilizza un indirizzamento relativo costituito dalla base + uno spiazzamento.\par
L'assegnazione dei valori ai registri segmento avviene all'inizio del programma, ma puo' essere modificata nel corso dell'esecuzione del programma.\line L'inizializzazione dei registri segmento dati (DS, ES, SS) \'e8 a carico del programmatore e non \'e8 ammesso l'indirizzamento immediato.\line OGni registro segmento punta alla base del segmento (locazione iniziale) e costituisce la base dell'indirizzo relativo.\line Offset invece puo' essere un numero immediato oppure puo' essere contenuto in un registro. Il registro utilizzato per esperimere l'offset pero' dipende dal segmento.\par
Rilocazione dinamica\line La segmentazione permette che la scrittura dei programmi sia indipendente dalla posizione. Si parla quindi di un programma rilocabile dinamicamente.\line Cio' consente ai sistemi in multiprogrammazione un uso effettivo della memoria disponibile, in quanto i programmi innativi possono risiedere un disco liberando spazio in memoria centrale. Verrano poi caricati un qualsiasi spazio disponibile all'occorrenza. Non c'\'e8 quindi una dipendenza dall'indirizzo di memoria in cui \'e8 allocato un programma.\line Sappiamo che le istruzioni devono essere eseguite in sequenza e quindi allocate in locazioni consecutive. La rilocabilit\'e0 consente di caricare l'intero programma a partire da indirizzi di memoria diversi (dove c'\'e8 spazio). In questo modo basta modificare la base dell'indirizzo relativo, ma lo spiazzamento non cambier\'e0: cio\'e8 la terza istruzione sar\'e0 sempre la terza istruzione, relativamente all'inizio del programma.\line\line Si possono distinguere 40 segnali, facenti capo ai relativi pin numerati.\line Le 20 linee del bus indirizzi (A0, A19)\line Le 20 linee del bus dati (D0, D15)\line Le linee del bus di controllo, tra cui il segnale di\line M/O (mory I/O)\line RD (Read)\line INTA (Interrupt ack: per il riconoscimento degli interrupt maschrabili)\line INTR (interrupt request per la richiesta di interrupt mascherabile)\line NMI (Not mascherable interrupt per l'invio di interrupt non mascherabile)\line BHE (per il trasferimento a 8 o 16 bit)\line Il clock per la temporizzazione delle opere\line\line MultiPlexaggio dati/indirizzi\line Il multiplexaggio dati/indirizzi (ADDR/DATA) dell'8086 consiste nell'interpretare i segnali che fanno capo agli stessi pin come indirizzo o come dato, in funziona del tempo in cui trnsitano.\line\line Viene effettuato utilizzando alcuni segnali del bus controllo: Tramite il latch 8282 abilitato dal segnale ALE, vengono memorizzati gli indirizzi che transitano sugli stessi 16 pin dei dati e transitano cos\'ec sull'address bus (ADDR)\line A Loro volta i dati vengono incanalati sul data bus (DATA), amplificati preventivamente tramite il transceiver 8288, abilitato tramite segnale DEN (Data enable) e posizionato in trasmissione/Ricezione tramite il segnale DT/R\line\line SOFTWARE 8086\line SINTASSI:\line <Codice mnemonico> <Operandi>\line\line Il numero di operandi puo' essere 0, 1 o 2.\line Si distinguono in destinatario e sorgente, secondo la seguente sintassi che evinzia che <dest> \'e8 il primo operando, <sorg> il secondo\line\tab\tab\tab cod <dest>,<sorg>\par
Regole di sintassi:\line Nelle istruzioni A/L il risultato \'e8 posto nel destinatario\line Se ci sono due operandi, uno solo puo' essere una locazione di memoria, l'altro \'e8 un registro o un dato immediato.\line La notazione con l'uso di parentesi quadre indica una locazione di memoria\line Esempio: ADD [SI], BX: Somma il contenuto del registro BX al contenuto della locazione di memoria il cui indirizzo \'e8 posto nel registro SI e metti il risultato nella ocazione di memoria in cui indirizzo \'e8 nel registro SI.\line\tab MOV AX, [0300h]: Trasferisci il contenuto della locazione di indirizzo 0300h nel \tab registro AX\line\tab MOV AX, 0300h Trasferisci il valore 0300h nel registro AX.\par
 Gli operandi possono essere:\line\f1\bullet\f0\lang1040 Dati immediati, registri, locazioni di memoria.\line\line Le istruzioni a due operandi permettono il trasferimento:\line\f1\bullet\f0 Registro a registro\line\f1\bullet\f0 Registro a memoria\line\f1\bullet\f0 Da memoria a registro\line\f1\bullet\f0 Da dato immediato a registro\line\f1\bullet\f0 Da dato immediato a memoria\line\line Se un istruzione coivolge due operandi, questi devono avere la stessa dimensione.\line\line Il programmatore deve sempre determinare con chiarezza la dimensione degli operandi e aver cura che essa sia sempre indicata in modo univoco alla CPU. La dimensione dei regitri \'e8 evidente, mentre la dimensione dei dati in memoria dipende dal constesto, poich\'e8 potrebbe essere di 8 o 16 bit\line\line I dati in memoria in genere sono contenuti nel segmento DATA\line nel segmento EXTRA o STACK.\line Nelle istruzioni viene esplicitato solo l'offset relativo al segmento DATA. Il nome del segmento di default \'e8 Data. Nel caso in cui invece si volesse di proposito utilizzare in un'istruzione un altro segmento, occore specificarlo.\line Esempio : MOV AL,[SI] >Trasferisce il contenuto della locazione posta all'indirizzo SD:SI nel \tab     registro AL\par
La codifica binaria di un'istruzione assembly prevede: \line\tab Codice operativo + operandi\line 1 b : codice operativo\line 1 b:  indicazioni sull'indirizzamento\line +4 b: al massimo.\lang16\line\line Per questo motivo, un'istruzione \'e8 lunga al massimo 6 byte.\line Il codice operativo occupa i lprimo byte, il secondo fornisce indicazioni sul metodo di indirizzamento e quindi su come interpretare i byte successivi.\line\line Le istruzioni possono essere scritte in maiuscolo o minuscolo\line\line METODI DI INDIRIZZAMENTO:\line Ricordiamo che il metodo di indirizzamento \'e8 il modo in cui la CPU reperisce gli operandi. Esistono metodi di indirizzamento che non coivolgono la memoria:\line\f1\bullet\f0 Immediato\line\f1\bullet\f0 A Registro\line\line E metodi che coinvolgono la memoria:\line\f1\bullet\f0 Diretto\line\f1\bullet\f0 Indiretto tramite registro\line\f1\bullet\f0 Indiretto a registro base con spostamento\line\f1\bullet\f0 Indiretto a registro base e indica\line\f1\bullet\f0 Indiretto a registro base, indice e spostamento.\line\line Indirizzamento immediato:\line L'istruzione contiene l'operando rappresentato da un dato numerico.\line Esso si trova in memoria nel segmento del codice.\line\line Indirizzamento a registro\line L'operando/i sono registri della CPU\line Es: MOV CL, AL\line\line Indirizzamento diretto\line Nell'istruzione \'e8contenuto direttamente l'offset di un indirizzo.\line Per completare l'indirizzo la CPU usa SD (di Default), altrimenti occorrere indicare nell'istruzione quale registro base utilizzare (OVERRIDE)\line Generlmente l'offset e espresso con un labl associata a un indirizzo, ma puo' essere usato un valore numero chiuso tra parentesi quadre.\line MOV DL, [1000h]\line\line Indirizzamento indiretto a registro\line L'offset si trova in: SI (DS) , DI (DS) , BX (DS) , BP (SS)\line Il registro contenente l'offset \'e8 espresso tra parentesi quadre\line Nel registro deve esserecaricato prima lo spiazzamento ,utilizzando l'istruzione lea (LOAD Effective andress). L'istruzione "lea" restituisce l'indirizzo in cui \'e8 allocato un dato, indirizzo che non \'e8 mai noto a priori.\line\line Indiretto a registro con spiazzamento\line L'offset \'e8 contenuto come nell'indirizzamento indiretto a registro m sommando algebricamente un valore costante\line mov BL, [SI +5]\line\line Indiretto a registro base e indice\line L'offset \'e8 contenuto usando i registri base e indice sommati\line MOV BL ,[BX+SI]\par
Indiretto a registro base, indice e spiazzamento\line L'offset \'e8 determinato dalla somma dei contenuti dei registri base e indice piu' un valore aggiunto\line MOV BL, [BX+SI+2]\line\line Istruzioni\line Trasferimento: MOV > L'istruzione mov permette vari tipi indirizzamento: mediato, diretto e indiretto.\line Copia Byte o World dall'operando sorgente a quello di destionazione.\line Spesso gli operandi dell'istruzione MOV sono i registri di uso generale.\par
\line ISTRUZIONI DI STATO\line Il registro di stato \'e8 costituito da 16 bit di cui 6 di stato e 3 di controllo. La tabella che segue sintetizza i bit del registro di stato.\line\line IStruzioni di rotazione e shit\line Rotazione: ROL, POR, RCL, RCR\line Shift: SHL, SHR, SAL, SAR.\line\line Sintassi: ROL dest, conteggio\line\tab i bit dell'operando scorrono di una posizione verso sinistra\line ROL BL,1\line\line SINTASSI: SHL dest, conteggio\line Descrizione: esegue lo scorrimento a sinsitra dei bit dell'operando un numero di volte pari a conteggio.\line\tab SHL Bl, 1\par
ISTRUZIONI SULLA STRINGHE\line MOVS > Sposta una stringa di byte, trasferisce il byte a un indirizzo all'altro.\par
LODx sorg\line Carica nell'accumulatore il contenuto dell'operando posto nel DS all'offset (SI]\line Incrementa o decrementa SI in base al valore di DF e della dimensione del dato\line\line STOx dest\line Memorizza in dest il cntenuto dell'acumulatore (AL o AX) e modifica DI: viene incrementata se DF viene decrementato\line Puo' essere preceduta da REP per caricare un dato costante in memoria\line STO ES:dato\line REP STOSW\line\line Si possono implementare le strutture di controllo\line If...then...else\line Case\line While...do\line For\par
ISTRUZIONI PER LA GESTIONE DELLO STACK\line Lo Stack viene usato per riferirsi a strutture dati le cui modalit\'e0 d'accesso eseguono la politica LIFO (Last In Frist Out). Ovvero tale per cui i dati vengono estratti in ordine rigorosamente inverso rispetto a quelli stati inseriti (scritti).\line Nei sistemi 80x86 lo stack cresce verso il basso, proprio come quando si consegnano i vassoi in mensa. La cima dello stack \'e8 puntata da SP\line\line PUSH > Carica un operando a 16 bit nello stack\line PUSH sorg\line PUSH AX, \tab PUSH BP,\line Decrementa SP di 2 e copia l'operando nella cima dello stack. L'operando della push non puo' essere di 8 bit.\line\line POP Preleva un dato a 16 bit dallo stack.\line POP dest\line POP AX\line Trasferisce un dato a  16 bit dalla cima dello stack al registro destinazione, operando di pop.\line Poi incrementa SP di 2 affinch\'e8 punti alla cima dello stack\line\line CALL Richiama procedure\line CALL dest\line CALL Procedure\line\line RET/RETF Ritorno da una procedura\line RET nBytes\line RETF nBytes\line Trasferisce il controllo da una procedura all'indirizzo il cui indirizzo era stato salvato nello stack.\par
\par
}
 